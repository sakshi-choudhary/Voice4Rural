{"ast":null,"code":"function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { css, propNames } from \"@chakra-ui/styled-system\";\nimport { memoizedGet as get, objectFilter, objectAssign, isFunction } from \"@chakra-ui/utils\";\nimport _styled from \"@emotion/styled\";\nimport { shouldForwardProp } from \"./should-forward-prop\";\nimport { domElements } from \"./system.utils\";\n/**\n * Convert propNames array to object to faster lookup perf\n */\n\nvar stylePropNames = propNames.reduce((keymirror, key) => {\n  if (typeof key !== \"object\" && typeof key !== \"function\") keymirror[key] = key;\n  return keymirror;\n}, {});\n/**\n * Style resolver function that manages how style props are merged\n * in combination with other possible ways of defining styles.\n *\n * For example, take a component defined this way:\n * ```jsx\n * <Box fontSize=\"24px\" sx={{ fontSize: \"40px\" }}></Box>\n * ```\n *\n * We want to manage the priority of the styles properly to prevent unwanted\n * behaviors. Right now, the `sx` prop has the highest priority so the resolved\n * fontSize will be `40px`\n */\n\nexport var getStyleObject = _ref => {\n  var {\n    baseStyle\n  } = _ref;\n  return props => {\n    var {\n      theme,\n      layerStyle,\n      textStyle,\n      apply,\n      noOfLines,\n      isTruncated,\n      css: cssProp,\n      __css,\n      sx\n    } = props,\n        rest = _objectWithoutPropertiesLoose(props, [\"theme\", \"layerStyle\", \"textStyle\", \"apply\", \"noOfLines\", \"isTruncated\", \"css\", \"__css\", \"sx\"]);\n\n    var _layerStyle = get(theme, \"layerStyles.\" + layerStyle, {});\n\n    var _textStyle = get(theme, \"textStyles.\" + textStyle, {}); // filter out props that aren't style props\n\n\n    var styleProps = objectFilter(rest, (_, prop) => prop in stylePropNames);\n    var truncateStyle = {};\n\n    if (noOfLines != null) {\n      truncateStyle = {\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        display: \"-webkit-box\",\n        WebkitBoxOrient: \"vertical\",\n        WebkitLineClamp: noOfLines\n      };\n    } else if (isTruncated) {\n      truncateStyle = {\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        whiteSpace: \"nowrap\"\n      };\n    }\n    /**\n     * The computed, theme-aware style object. The other of the properties\n     * within `objectAssign` determines how styles are overriden.\n     */\n\n\n    var finalStyles = objectAssign({}, __css, baseStyle, {\n      apply\n    }, _layerStyle, _textStyle, truncateStyle, styleProps, sx); // Converts theme-aware style object to real css object\n\n    var computedCSS = css(finalStyles)(props.theme); // Merge the computed css object with styles in css prop\n\n    var cssObject = objectAssign(computedCSS, isFunction(cssProp) ? cssProp(theme) : cssProp);\n    return cssObject;\n  };\n};\nexport function styled(component, options) {\n  var _ref2 = options != null ? options : {},\n      {\n    baseStyle\n  } = _ref2,\n      styledOptions = _objectWithoutPropertiesLoose(_ref2, [\"baseStyle\"]);\n\n  if (!styledOptions.shouldForwardProp) {\n    styledOptions.shouldForwardProp = shouldForwardProp;\n  }\n\n  var styleObject = getStyleObject({\n    baseStyle\n  });\n  return _styled(component, styledOptions)(styleObject);\n}\nexport var chakra = styled;\ndomElements.forEach(tag => {\n  chakra[tag] = chakra(tag);\n});","map":{"version":3,"sources":["../../src/system.ts"],"names":["memoizedGet","stylePropNames","keymirror","getStyleObject","baseStyle","props","css","sx","rest","_layerStyle","get","_textStyle","styleProps","objectFilter","prop","truncateStyle","noOfLines","overflow","textOverflow","display","WebkitBoxOrient","WebkitLineClamp","whiteSpace","finalStyles","objectAssign","apply","computedCSS","cssObject","isFunction","cssProp","styledOptions","options","styleObject","_styled","chakra","domElements","tag"],"mappings":"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","sourcesContent":["import {\n  css,\n  propNames,\n  ResponsiveValue,\n  SystemProps,\n  SystemStyleObject,\n  ChakraStyleProps,\n} from \"@chakra-ui/styled-system\"\nimport {\n  memoizedGet as get,\n  objectFilter,\n  objectAssign,\n  Dict,\n  isFunction,\n} from \"@chakra-ui/utils\"\nimport _styled, {\n  CSSObject,\n  FunctionInterpolation,\n  Interpolation,\n} from \"@emotion/styled\"\nimport { shouldForwardProp } from \"./should-forward-prop\"\nimport { As, ChakraComponent, ChakraProps, PropsOf } from \"./system.types\"\nimport { domElements, DOMElements } from \"./system.utils\"\n\n/**\n * Convert propNames array to object to faster lookup perf\n */\nconst stylePropNames = propNames.reduce((keymirror, key) => {\n  if (typeof key !== \"object\" && typeof key !== \"function\") keymirror[key] = key\n  return keymirror\n}, {})\n\ninterface StyleResolverProps extends SystemProps {\n  __css?: SystemStyleObject\n  sx?: SystemStyleObject\n  theme: Dict\n  css?: CSSObject\n  noOfLines?: ResponsiveValue<number>\n  isTruncated?: boolean\n  layerStyle?: string\n  textStyle?: string\n  apply?: ResponsiveValue<string>\n}\n\ntype GetStyleObject = (options: {\n  baseStyle?: SystemStyleObject\n}) => FunctionInterpolation<StyleResolverProps>\n\n/**\n * Style resolver function that manages how style props are merged\n * in combination with other possible ways of defining styles.\n *\n * For example, take a component defined this way:\n * ```jsx\n * <Box fontSize=\"24px\" sx={{ fontSize: \"40px\" }}></Box>\n * ```\n *\n * We want to manage the priority of the styles properly to prevent unwanted\n * behaviors. Right now, the `sx` prop has the highest priority so the resolved\n * fontSize will be `40px`\n */\nexport const getStyleObject: GetStyleObject = ({ baseStyle }) => (props) => {\n  const {\n    theme,\n    layerStyle,\n    textStyle,\n    apply,\n    noOfLines,\n    isTruncated,\n    css: cssProp,\n    __css,\n    sx,\n    ...rest\n  } = props\n\n  const _layerStyle = get(theme, `layerStyles.${layerStyle}`, {})\n  const _textStyle = get(theme, `textStyles.${textStyle}`, {})\n\n  // filter out props that aren't style props\n  const styleProps = objectFilter(rest, (_, prop) => prop in stylePropNames)\n\n  let truncateStyle: any = {}\n\n  if (noOfLines != null) {\n    truncateStyle = {\n      overflow: \"hidden\",\n      textOverflow: \"ellipsis\",\n      display: \"-webkit-box\",\n      WebkitBoxOrient: \"vertical\",\n      WebkitLineClamp: noOfLines,\n    }\n  } else if (isTruncated) {\n    truncateStyle = {\n      overflow: \"hidden\",\n      textOverflow: \"ellipsis\",\n      whiteSpace: \"nowrap\",\n    }\n  }\n\n  /**\n   * The computed, theme-aware style object. The other of the properties\n   * within `objectAssign` determines how styles are overriden.\n   */\n  const finalStyles = objectAssign(\n    {},\n    __css,\n    baseStyle,\n    { apply },\n    _layerStyle,\n    _textStyle,\n    truncateStyle,\n    styleProps,\n    sx,\n  )\n\n  // Converts theme-aware style object to real css object\n  const computedCSS = css(finalStyles)(props.theme)\n\n  // Merge the computed css object with styles in css prop\n  const cssObject: Interpolation<StyleResolverProps> = objectAssign(\n    computedCSS,\n    isFunction(cssProp) ? cssProp(theme) : cssProp,\n  )\n\n  return cssObject\n}\n\ninterface StyledOptions {\n  shouldForwardProp?(prop: string): boolean\n  label?: string\n  baseStyle?: SystemStyleObject\n}\n\nexport function styled<T extends As, P = {}>(\n  component: T,\n  options?: StyledOptions,\n) {\n  const { baseStyle, ...styledOptions } = options ?? {}\n\n  if (!styledOptions.shouldForwardProp) {\n    styledOptions.shouldForwardProp = shouldForwardProp\n  }\n\n  const styleObject = getStyleObject({ baseStyle })\n  return _styled(\n    component as React.ComponentType<any>,\n    styledOptions,\n  )(styleObject) as ChakraComponent<T, P>\n}\n\nexport type HTMLChakraComponents = {\n  [Tag in DOMElements]: ChakraComponent<Tag, {}>\n}\n\nexport type HTMLChakraProps<T extends As> = Omit<\n  PropsOf<T>,\n  T extends \"svg\"\n    ? \"ref\" | \"children\" | keyof ChakraStyleProps\n    : \"ref\" | keyof ChakraStyleProps\n> &\n  ChakraProps & { as?: As }\n\ntype ChakraFactory = {\n  <T extends As, P = {}>(\n    component: T,\n    options?: StyledOptions,\n  ): ChakraComponent<T, P>\n}\n\nexport const chakra = (styled as unknown) as ChakraFactory &\n  HTMLChakraComponents\n\ndomElements.forEach((tag) => {\n  chakra[tag] = chakra(tag)\n})\n"]},"metadata":{},"sourceType":"module"}