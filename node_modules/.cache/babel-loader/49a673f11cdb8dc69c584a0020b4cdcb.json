{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useControllableState, useUpdateEffect } from \"@chakra-ui/hooks\";\nimport { ariaAttr, callAllHandlers, isEmpty, mergeRefs, normalizeEventKey } from \"@chakra-ui/utils\";\nimport { useCallback, useRef, useState } from \"react\";\n/**\n * React hook for managing the inline renaming of some text.\n *\n * @see Docs https://chakra-ui.com/docs/editable\n */\n\nexport function useEditable(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var {\n    onChange: onChangeProp,\n    onCancel: onCancelProp,\n    onSubmit: onSubmitProp,\n    value: valueProp,\n    isDisabled,\n    defaultValue,\n    startWithEditView,\n    isPreviewFocusable = true,\n    submitOnBlur = true,\n    selectAllOnFocus = true,\n    placeholder,\n    onEdit: onEditProp\n  } = props,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"onChange\", \"onCancel\", \"onSubmit\", \"value\", \"isDisabled\", \"defaultValue\", \"startWithEditView\", \"isPreviewFocusable\", \"submitOnBlur\", \"selectAllOnFocus\", \"placeholder\", \"onEdit\"]);\n\n  var defaultIsEditing = Boolean(startWithEditView && !isDisabled);\n  var [isEditing, setIsEditing] = useState(defaultIsEditing);\n  var [value, setValue] = useControllableState({\n    defaultValue: defaultValue || \"\",\n    value: valueProp,\n    onChange: onChangeProp\n  });\n  /**\n   * Keep track of the previous value, so if users\n   * presses `cancel`, we can revert to it.\n   */\n\n  var [prevValue, setPrevValue] = useState(value);\n  /**\n   * Ref to help focus the input in edit mode\n   */\n\n  var inputRef = useRef(null);\n  var previewRef = useRef(null);\n  var editButtonRef = useRef(null);\n  var isInteractive = !isEditing || !isDisabled;\n  useUpdateEffect(() => {\n    if (!isEditing) {\n      var _editButtonRef$curren;\n\n      (_editButtonRef$curren = editButtonRef.current) == null ? void 0 : _editButtonRef$curren.focus();\n      return;\n    }\n\n    if (selectAllOnFocus) {\n      var _inputRef$current;\n\n      (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.select();\n    } else {\n      var _inputRef$current2;\n\n      (_inputRef$current2 = inputRef.current) == null ? void 0 : _inputRef$current2.focus();\n    }\n\n    onEditProp == null ? void 0 : onEditProp();\n  }, [isEditing, onEditProp, selectAllOnFocus]);\n  var onEdit = useCallback(() => {\n    if (isInteractive) {\n      setIsEditing(true);\n    }\n  }, [isInteractive]);\n  var onCancel = useCallback(() => {\n    setIsEditing(false);\n    setValue(prevValue);\n    onCancelProp == null ? void 0 : onCancelProp(prevValue);\n  }, [onCancelProp, setValue, prevValue]);\n  var onSubmit = useCallback(() => {\n    setIsEditing(false);\n    setPrevValue(value);\n    onSubmitProp == null ? void 0 : onSubmitProp(value);\n  }, [value, onSubmitProp]);\n  var onChange = useCallback(event => {\n    setValue(event.target.value);\n  }, [setValue]);\n  var onKeyDown = useCallback(event => {\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      Escape: onCancel,\n      Enter: event => {\n        if (!event.shiftKey && !event.metaKey) {\n          onSubmit();\n        }\n      }\n    };\n    var action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [onCancel, onSubmit]);\n  var isValueEmpty = isEmpty(value);\n\n  var getTabIndex = () => {\n    var shouldHaveTabIndex = isInteractive && isPreviewFocusable;\n    return shouldHaveTabIndex ? 0 : undefined;\n  };\n\n  var onBlur = useCallback(() => {\n    if (submitOnBlur) {\n      onSubmit();\n    }\n  }, [submitOnBlur, onSubmit]);\n\n  var getPreviewProps = function getPreviewProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: mergeRefs(ref, previewRef),\n      children: isValueEmpty ? placeholder : value,\n      hidden: isEditing,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      tabIndex: getTabIndex(),\n      onFocus: callAllHandlers(props.onFocus, onEdit)\n    });\n  };\n\n  var getInputProps = function getInputProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      hidden: !isEditing,\n      placeholder,\n      ref: mergeRefs(ref, inputRef),\n      disabled: isDisabled,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      value,\n      onBlur: callAllHandlers(props.onBlur, onBlur),\n      onChange: callAllHandlers(props.onChange, onChange),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n    });\n  };\n\n  var getEditButtonProps = function getEditButtonProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({\n      \"aria-label\": \"Edit\"\n    }, props, {\n      type: \"button\",\n      onClick: callAllHandlers(props.onClick, onEdit),\n      ref: mergeRefs(ref, editButtonRef)\n    });\n  };\n\n  var getSubmitButtonProps = function getSubmitButtonProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      \"aria-label\": \"Submit\",\n      ref,\n      type: \"button\",\n      onClick: callAllHandlers(props.onClick, onSubmit)\n    });\n  };\n\n  var getCancelButtonProps = function getCancelButtonProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({\n      \"aria-label\": \"Cancel\"\n    }, props, {\n      ref,\n      type: \"button\",\n      onClick: callAllHandlers(props.onClick, onCancel)\n    });\n  };\n\n  return {\n    isEditing,\n    isDisabled,\n    isValueEmpty,\n    value,\n    onEdit,\n    onCancel,\n    onSubmit,\n    getPreviewProps,\n    getInputProps,\n    getEditButtonProps,\n    getSubmitButtonProps,\n    getCancelButtonProps,\n    htmlProps\n  };\n}","map":{"version":3,"sources":["../../src/use-editable.ts"],"names":["props","onChange","onCancel","onSubmit","value","isPreviewFocusable","submitOnBlur","selectAllOnFocus","onEdit","onEditProp","htmlProps","defaultIsEditing","Boolean","startWithEditView","useState","useControllableState","defaultValue","onChangeProp","inputRef","useRef","previewRef","editButtonRef","isInteractive","useUpdateEffect","useCallback","setIsEditing","setValue","onCancelProp","setPrevValue","onSubmitProp","event","onKeyDown","eventKey","normalizeEventKey","keyMap","Escape","Enter","action","isValueEmpty","isEmpty","getTabIndex","shouldHaveTabIndex","onBlur","getPreviewProps","ref","mergeRefs","children","hidden","ariaAttr","tabIndex","onFocus","callAllHandlers","getInputProps","disabled","getEditButtonProps","type","onClick","getSubmitButtonProps","getCancelButtonProps"],"mappings":"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","sourcesContent":["import { useControllableState, useUpdateEffect } from \"@chakra-ui/hooks\"\nimport {\n  ariaAttr,\n  callAllHandlers,\n  EventKeyMap,\n  isEmpty,\n  mergeRefs,\n  normalizeEventKey,\n  PropGetter,\n} from \"@chakra-ui/utils\"\nimport { ChangeEvent, useCallback, useRef, useState } from \"react\"\n\nexport interface UseEditableProps {\n  /**\n   * The value of the Editable in both edit & preview mode\n   */\n  value?: string\n  /**\n   * The initial value of the Editable in both edit & preview mode\n   */\n  defaultValue?: string\n  /**\n   * If `true`, the Editable will be disabled.\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the Editable will start with edit mode by default.\n   */\n  startWithEditView?: boolean\n  /**\n   * If `true`, the read only view, has a `tabIndex` set to `0`\n   * so it can recieve focus via the keyboard or click.\n   * @default true\n   */\n  isPreviewFocusable?: boolean\n  /**\n   * If `true`, it'll update the value onBlur and turn off the edit mode.\n   * @default true\n   */\n  submitOnBlur?: boolean\n  /**\n   * Callback invoked when user changes input.\n   */\n  onChange?: (nextValue: string) => void\n  /**\n   * Callback invoked when user cancels input with the `Esc` key.\n   * It provides the last confirmed value as argument.\n   */\n  onCancel?: (previousValue: string) => void\n  /**\n   * Callback invoked when user confirms value with `enter` key or by blurring input.\n   */\n  onSubmit?: (nextValue: string) => void\n  /**\n   * Callback invoked once the user enters edit mode.\n   */\n  onEdit?: () => void\n  /**\n   * If `true`, the input's text will be highlighted on focus.\n   * @default true\n   */\n  selectAllOnFocus?: boolean\n  /**\n   * The placeholder text when the value is empty.\n   */\n  placeholder?: string\n}\n\n/**\n * React hook for managing the inline renaming of some text.\n *\n * @see Docs https://chakra-ui.com/docs/editable\n */\nexport function useEditable(props: UseEditableProps = {}) {\n  const {\n    onChange: onChangeProp,\n    onCancel: onCancelProp,\n    onSubmit: onSubmitProp,\n    value: valueProp,\n    isDisabled,\n    defaultValue,\n    startWithEditView,\n    isPreviewFocusable = true,\n    submitOnBlur = true,\n    selectAllOnFocus = true,\n    placeholder,\n    onEdit: onEditProp,\n    ...htmlProps\n  } = props\n\n  const defaultIsEditing = Boolean(startWithEditView && !isDisabled)\n\n  const [isEditing, setIsEditing] = useState(defaultIsEditing)\n\n  const [value, setValue] = useControllableState({\n    defaultValue: defaultValue || \"\",\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n\n  /**\n   * Keep track of the previous value, so if users\n   * presses `cancel`, we can revert to it.\n   */\n  const [prevValue, setPrevValue] = useState(value)\n\n  /**\n   * Ref to help focus the input in edit mode\n   */\n  const inputRef = useRef<HTMLInputElement>(null)\n  const previewRef = useRef<any>(null)\n\n  const editButtonRef = useRef<HTMLButtonElement>(null)\n\n  const isInteractive = !isEditing || !isDisabled\n\n  useUpdateEffect(() => {\n    if (!isEditing) {\n      editButtonRef.current?.focus()\n      return\n    }\n\n    if (selectAllOnFocus) {\n      inputRef.current?.select()\n    } else {\n      inputRef.current?.focus()\n    }\n\n    onEditProp?.()\n  }, [isEditing, onEditProp, selectAllOnFocus])\n\n  const onEdit = useCallback(() => {\n    if (isInteractive) {\n      setIsEditing(true)\n    }\n  }, [isInteractive])\n\n  const onCancel = useCallback(() => {\n    setIsEditing(false)\n    setValue(prevValue)\n    onCancelProp?.(prevValue)\n  }, [onCancelProp, setValue, prevValue])\n\n  const onSubmit = useCallback(() => {\n    setIsEditing(false)\n    setPrevValue(value)\n    onSubmitProp?.(value)\n  }, [value, onSubmitProp])\n\n  const onChange = useCallback(\n    (event: ChangeEvent<HTMLInputElement>) => {\n      setValue(event.target.value)\n    },\n    [setValue],\n  )\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = normalizeEventKey(event)\n\n      const keyMap: EventKeyMap = {\n        Escape: onCancel,\n        Enter: (event) => {\n          if (!event.shiftKey && !event.metaKey) {\n            onSubmit()\n          }\n        },\n      }\n\n      const action = keyMap[eventKey]\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [onCancel, onSubmit],\n  )\n\n  const isValueEmpty = isEmpty(value)\n\n  const getTabIndex = () => {\n    const shouldHaveTabIndex = isInteractive && isPreviewFocusable\n    return shouldHaveTabIndex ? 0 : undefined\n  }\n\n  const onBlur = useCallback(() => {\n    if (submitOnBlur) {\n      onSubmit()\n    }\n  }, [submitOnBlur, onSubmit])\n\n  const getPreviewProps: PropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref: mergeRefs(ref, previewRef),\n    children: isValueEmpty ? placeholder : value,\n    hidden: isEditing,\n    \"aria-disabled\": ariaAttr(isDisabled),\n    tabIndex: getTabIndex(),\n    onFocus: callAllHandlers(props.onFocus, onEdit),\n  })\n\n  const getInputProps: PropGetter = (props = {}, ref = null) => ({\n    ...props,\n    hidden: !isEditing,\n    placeholder,\n    ref: mergeRefs(ref, inputRef),\n    disabled: isDisabled,\n    \"aria-disabled\": ariaAttr(isDisabled),\n    value,\n    onBlur: callAllHandlers(props.onBlur, onBlur),\n    onChange: callAllHandlers(props.onChange, onChange),\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  })\n\n  const getEditButtonProps: PropGetter = (props = {}, ref = null) => ({\n    \"aria-label\": \"Edit\",\n    ...props,\n    type: \"button\",\n    onClick: callAllHandlers(props.onClick, onEdit),\n    ref: mergeRefs(ref, editButtonRef),\n  })\n\n  const getSubmitButtonProps: PropGetter = (props = {}, ref = null) => ({\n    ...props,\n    \"aria-label\": \"Submit\",\n    ref,\n    type: \"button\",\n    onClick: callAllHandlers(props.onClick, onSubmit),\n  })\n\n  const getCancelButtonProps: PropGetter = (props = {}, ref = null) => ({\n    \"aria-label\": \"Cancel\",\n    ...props,\n    ref,\n    type: \"button\",\n    onClick: callAllHandlers(props.onClick, onCancel),\n  })\n\n  return {\n    isEditing,\n    isDisabled,\n    isValueEmpty,\n    value,\n    onEdit,\n    onCancel,\n    onSubmit,\n    getPreviewProps,\n    getInputProps,\n    getEditButtonProps,\n    getSubmitButtonProps,\n    getCancelButtonProps,\n    htmlProps,\n  }\n}\n\nexport type UseEditableReturn = ReturnType<typeof useEditable>\n"]},"metadata":{},"sourceType":"module"}