{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useBoolean, useControllableState, useDimensions, useCallbackRef, useEventListener, useIds, useUnmountEffect, useUpdateEffect } from \"@chakra-ui/hooks\";\nimport { ariaAttr, callAllHandlers, clampValue, dataAttr, focus, getBox, getOwnerDocument, isRightClick, mergeRefs, normalizeEventKey, percentToValue, roundValueToStep, valueToPercent } from \"@chakra-ui/utils\";\nimport { useCallback, useMemo, useRef, useState } from \"react\";\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\n\nexport function useSlider(props) {\n  var _getAriaValueText, _thumbBoxModel$border;\n\n  var {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed,\n    orientation,\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart,\n    onChangeEnd,\n    step = 1,\n    getAriaValueText,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true\n  } = props,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"min\", \"max\", \"onChange\", \"value\", \"defaultValue\", \"isReversed\", \"orientation\", \"id\", \"isDisabled\", \"isReadOnly\", \"onChangeStart\", \"onChangeEnd\", \"step\", \"getAriaValueText\", \"aria-valuetext\", \"aria-label\", \"aria-labelledby\", \"name\", \"focusThumbOnChange\"]);\n\n  var [isDragging, setDragging] = useBoolean();\n  var [isFocused, setFocused] = useBoolean();\n  var [eventSource, setEventSource] = useState();\n  var isInteractive = !(isDisabled || isReadOnly);\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n\n  var [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : getDefaultValue(min, max),\n    onChange\n  });\n  /**\n   * Slider uses DOM APIs to add and remove event listeners.\n   * Noticed some issues with React's synthetic events.\n   *\n   * We use `ref` to save the functions used to remove\n   * the event listeners.\n   *\n   * Ideally, we'll love to use pointer-events API but it is\n   * not fully supported in all browsers.\n   */\n\n  var cleanUpRef = useRef({});\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n\n  var value = clampValue(computedValue, min, max);\n  var prev = useRef();\n  var reversedValue = max - value + min;\n  var trackValue = isReversed ? reversedValue : value;\n  var trackPercent = valueToPercent(trackValue, min, max);\n  var isVertical = orientation === \"vertical\";\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n\n  var trackRef = useRef(null);\n  var thumbRef = useRef(null);\n  var rootRef = useRef(null);\n  /**\n   * Generate unique ids for component parts\n   */\n\n  var [thumbId, trackId] = useIds(idProp, \"slider-thumb\", \"slider-track\");\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   */\n\n  var getValueFromPointer = useCallback(event => {\n    var _event$touches$, _event$touches;\n\n    if (!trackRef.current) return undefined;\n    var trackRect = getBox(trackRef.current).borderBox;\n    var {\n      clientX,\n      clientY\n    } = (_event$touches$ = (_event$touches = event.touches) == null ? void 0 : _event$touches[0]) != null ? _event$touches$ : event;\n    var diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;\n    var length = isVertical ? trackRect.height : trackRect.width;\n    var percent = diff / length;\n\n    if (isReversed) {\n      percent = 1 - percent;\n    }\n\n    var nextValue = percentToValue(percent, min, max);\n\n    if (step) {\n      nextValue = parseFloat(roundValueToStep(nextValue, min, step));\n    }\n\n    nextValue = clampValue(nextValue, min, max);\n    return nextValue;\n  }, [isVertical, isReversed, max, min, step]);\n  var tenSteps = (max - min) / 10;\n  var oneStep = step || (max - min) / 100;\n  var constrain = useCallback(value => {\n    // bail out if slider isn't interactive\n    if (!isInteractive) return;\n    prev.current = value;\n    value = parseFloat(roundValueToStep(value, min, oneStep));\n    value = clampValue(value, min, max);\n    setValue(value);\n  }, [oneStep, max, min, setValue, isInteractive]);\n  var actions = useMemo(() => ({\n    stepUp: function stepUp(step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n\n      var next = isReversed ? value - step : value + step;\n      constrain(next);\n    },\n    stepDown: function stepDown(step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n\n      var next = isReversed ? value + step : value - step;\n      constrain(next);\n    },\n    reset: () => constrain(defaultValue || 0),\n    stepTo: value => constrain(value)\n  }), [constrain, isReversed, value, oneStep, defaultValue]);\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n\n  var onKeyDown = useCallback(event => {\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowRight: () => actions.stepUp(),\n      ArrowUp: () => actions.stepUp(),\n      ArrowLeft: () => actions.stepDown(),\n      ArrowDown: () => actions.stepDown(),\n      PageUp: () => actions.stepUp(tenSteps),\n      PageDown: () => actions.stepDown(tenSteps),\n      Home: () => constrain(min),\n      End: () => constrain(max)\n    };\n    var action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      setEventSource(\"keyboard\");\n      action(event);\n    }\n  }, [actions, constrain, max, min, tenSteps]);\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n\n  var valueText = (_getAriaValueText = getAriaValueText == null ? void 0 : getAriaValueText(value)) != null ? _getAriaValueText : ariaValueText;\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n\n  var thumbBoxModel = useDimensions(thumbRef);\n  var thumbRect = (_thumbBoxModel$border = thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox) != null ? _thumbBoxModel$border : {\n    width: 0,\n    height: 0\n  };\n  /**\n   * Compute styles for all component parts.\n   */\n\n  var thumbStyle = _extends({\n    position: \"absolute\",\n    userSelect: \"none\",\n    touchAction: \"none\"\n  }, orient({\n    orientation,\n    vertical: {\n      bottom: \"calc(\" + trackPercent + \"% - \" + thumbRect.height / 2 + \"px)\"\n    },\n    horizontal: {\n      left: \"calc(\" + trackPercent + \"% - \" + thumbRect.width / 2 + \"px)\"\n    }\n  }));\n\n  var rootStyle = _extends({\n    position: \"relative\",\n    touchAction: \"none\",\n    WebkitTapHighlightColor: \"rgba(0,0,0,0)\",\n    userSelect: \"none\",\n    outline: 0\n  }, orient({\n    orientation,\n    vertical: {\n      paddingLeft: thumbRect.width / 2,\n      paddingRight: thumbRect.width / 2\n    },\n    horizontal: {\n      paddingTop: thumbRect.height / 2,\n      paddingBottom: thumbRect.height / 2\n    }\n  }));\n\n  var trackStyle = _extends({\n    position: \"absolute\"\n  }, orient({\n    orientation,\n    vertical: {\n      left: \"50%\",\n      transform: \"translateX(-50%)\",\n      height: \"100%\"\n    },\n    horizontal: {\n      top: \"50%\",\n      transform: \"translateY(-50%)\",\n      width: \"100%\"\n    }\n  }));\n\n  var innerTrackStyle = _extends({}, trackStyle, orient({\n    orientation,\n    vertical: isReversed ? {\n      height: 100 - trackPercent + \"%\",\n      top: 0\n    } : {\n      height: trackPercent + \"%\",\n      bottom: 0\n    },\n    horizontal: isReversed ? {\n      width: 100 - trackPercent + \"%\",\n      right: 0\n    } : {\n      width: trackPercent + \"%\",\n      left: 0\n    }\n  }));\n\n  useUpdateEffect(() => {\n    if (thumbRef.current && focusThumbOnChange) {\n      focus(thumbRef.current);\n    }\n  }, [value]);\n  useUpdateEffect(() => {\n    var shouldUpdate = !isDragging && eventSource !== \"keyboard\" && prev.current !== value;\n\n    if (shouldUpdate) {\n      onChangeEnd == null ? void 0 : onChangeEnd(value);\n    }\n\n    if (eventSource === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(value);\n    }\n  }, [isDragging, onChangeEnd, value, eventSource]);\n  var onMouseDown = useCallbackRef(event => {\n    /**\n     * Prevent update if it is right-click\n     */\n    if (isRightClick(event)) return;\n    if (!isInteractive || !rootRef.current) return;\n    setDragging.on();\n    prev.current = value;\n    onChangeStart == null ? void 0 : onChangeStart(value);\n    var doc = getOwnerDocument(rootRef.current);\n\n    var run = event => {\n      var nextValue = getValueFromPointer(event);\n\n      if (nextValue != null) {\n        setEventSource(\"mouse\");\n        setValue(nextValue);\n      }\n    };\n\n    run(event);\n    doc == null ? void 0 : doc.addEventListener(\"mousemove\", run);\n\n    var clean = () => {\n      doc == null ? void 0 : doc.removeEventListener(\"mousemove\", run);\n      setDragging.off();\n    };\n\n    doc == null ? void 0 : doc.addEventListener(\"mouseup\", clean);\n\n    cleanUpRef.current.mouseup = () => {\n      doc == null ? void 0 : doc.removeEventListener(\"mouseup\", clean);\n    };\n  });\n  var onTouchStart = useCallbackRef(event => {\n    if (!isInteractive || !rootRef.current) return; // Prevent scrolling for touch events\n\n    event.preventDefault();\n    setDragging.on();\n    prev.current = value;\n    onChangeStart == null ? void 0 : onChangeStart(value);\n    var doc = getOwnerDocument(rootRef.current);\n\n    var run = event => {\n      var nextValue = getValueFromPointer(event);\n\n      if (nextValue != null) {\n        setEventSource(\"touch\");\n        setValue(nextValue);\n      }\n    };\n\n    run(event);\n    doc == null ? void 0 : doc.addEventListener(\"touchmove\", run);\n\n    var clean = () => {\n      doc == null ? void 0 : doc.removeEventListener(\"touchmove\", run);\n      setDragging.off();\n    };\n\n    doc == null ? void 0 : doc.addEventListener(\"touchend\", clean);\n    doc == null ? void 0 : doc.addEventListener(\"touchcancel\", clean);\n\n    cleanUpRef.current.touchend = () => {\n      doc == null ? void 0 : doc.removeEventListener(\"touchend\", clean);\n    };\n\n    cleanUpRef.current.touchcancel = () => {\n      doc == null ? void 0 : doc.removeEventListener(\"touchcancel\", clean);\n    };\n  });\n  /**\n   * Remove all event handlers\n   */\n\n  var detach = () => {\n    Object.values(cleanUpRef.current).forEach(cleanup => {\n      cleanup == null ? void 0 : cleanup();\n    });\n    cleanUpRef.current = {};\n  };\n  /**\n   * Ensure we clean up listeners when slider unmounts\n   */\n\n\n  useUnmountEffect(detach);\n  useUpdateEffect(() => {\n    if (!isDragging) detach();\n  }, [isDragging]);\n  cleanUpRef.current.mousedown = useEventListener(\"mousedown\", onMouseDown, rootRef.current);\n  cleanUpRef.current.touchstart = useEventListener(\"touchstart\", onTouchStart, rootRef.current);\n\n  var getRootProps = function getRootProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, htmlProps, {\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: _extends({}, props.style, rootStyle)\n    });\n  };\n\n  var getTrackProps = function getTrackProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: _extends({}, props.style, trackStyle)\n    });\n  };\n\n  var getInnerTrackProps = function getInnerTrackProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref,\n      style: _extends({}, props.style, innerTrackStyle)\n    });\n  };\n\n  var getThumbProps = function getThumbProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: 0,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n      style: _extends({}, props.style, thumbStyle),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, setFocused.on),\n      onBlur: callAllHandlers(props.onBlur, setFocused.off)\n    });\n  };\n\n  var getMarkerProps = function getMarkerProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    var isInRange = !(props.value < min || props.value > max);\n    var isHighlighted = value >= props.value;\n    var markerPercent = valueToPercent(props.value, min, max);\n\n    var markerStyle = _extends({\n      position: \"absolute\",\n      pointerEvents: \"none\"\n    }, orient({\n      orientation,\n      vertical: {\n        bottom: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      },\n      horizontal: {\n        left: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      }\n    }));\n\n    return _extends({}, props, {\n      ref,\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: _extends({}, props.style, markerStyle)\n    });\n  };\n\n  var getInputProps = function getInputProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref,\n      type: \"hidden\",\n      value,\n      name\n    });\n  };\n\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps\n  };\n}\n\nfunction orient(options) {\n  var {\n    orientation,\n    vertical,\n    horizontal\n  } = options;\n  return orientation === \"vertical\" ? vertical : horizontal;\n}\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\n\n\nfunction getDefaultValue(min, max) {\n  return max < min ? min : min + (max - min) / 2;\n}","map":{"version":3,"sources":["../../src/use-slider.ts"],"names":["min","max","value","id","step","focusThumbOnChange","htmlProps","useBoolean","useState","isInteractive","isDisabled","useControllableState","defaultValue","getDefaultValue","onChange","cleanUpRef","useRef","clampValue","prev","reversedValue","trackValue","isReversed","trackPercent","valueToPercent","isVertical","orientation","trackRef","thumbRef","rootRef","useIds","getValueFromPointer","useCallback","event","trackRect","getBox","clientY","diff","clientX","length","percent","nextValue","percentToValue","parseFloat","roundValueToStep","tenSteps","oneStep","constrain","setValue","actions","useMemo","stepUp","next","stepDown","reset","stepTo","onKeyDown","eventKey","normalizeEventKey","keyMap","ArrowRight","ArrowUp","ArrowLeft","ArrowDown","PageUp","PageDown","Home","End","action","setEventSource","valueText","getAriaValueText","thumbBoxModel","useDimensions","thumbRect","width","height","thumbStyle","position","userSelect","touchAction","orient","vertical","bottom","horizontal","left","rootStyle","WebkitTapHighlightColor","outline","paddingLeft","paddingRight","paddingTop","paddingBottom","trackStyle","transform","top","innerTrackStyle","right","useUpdateEffect","focus","shouldUpdate","eventSource","onChangeEnd","onMouseDown","useCallbackRef","isRightClick","setDragging","onChangeStart","doc","getOwnerDocument","run","clean","onTouchStart","detach","Object","cleanup","useUnmountEffect","useEventListener","getRootProps","props","ref","mergeRefs","tabIndex","ariaAttr","dataAttr","style","getTrackProps","getInnerTrackProps","getThumbProps","role","ariaLabel","callAllHandlers","onFocus","setFocused","onBlur","getMarkerProps","isInRange","isHighlighted","markerPercent","markerStyle","pointerEvents","getInputProps","type","name","state","isDragging"],"mappings":"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","sourcesContent":["import {\n  useBoolean,\n  useControllableState,\n  useDimensions,\n  useCallbackRef,\n  useEventListener,\n  useIds,\n  useUnmountEffect,\n  useUpdateEffect,\n} from \"@chakra-ui/hooks\"\nimport {\n  ariaAttr,\n  callAllHandlers,\n  clampValue,\n  dataAttr,\n  Dict,\n  EventKeyMap,\n  focus,\n  getBox,\n  getOwnerDocument,\n  isRightClick,\n  mergeRefs,\n  normalizeEventKey,\n  percentToValue,\n  PropGetter,\n  roundValueToStep,\n  valueToPercent,\n} from \"@chakra-ui/utils\"\nimport { CSSProperties, useCallback, useMemo, useRef, useState } from \"react\"\n\nexport interface UseSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number\n  /**\n   * orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   */\n  isReversed?: boolean\n  /**\n   * function gets called whenever the user starts dragging the slider handle\n   */\n  onChangeStart?(value: number): void\n  /**\n   * function gets called whenever the user stops dragging the slider handle.\n   */\n  onChangeEnd?(value: number): void\n  /**\n   * function gets called whenever the slider handle is being dragged or clicked\n   */\n  onChange?(value: number): void\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string\n  /**\n   * If `true`, the slider will be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   */\n  isReadOnly?: boolean\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string\n}\n\ntype EventSource = \"mouse\" | \"touch\" | \"keyboard\"\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\nexport function useSlider(props: UseSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed,\n    orientation,\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart,\n    onChangeEnd,\n    step = 1,\n    getAriaValueText,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    ...htmlProps\n  } = props\n\n  const [isDragging, setDragging] = useBoolean()\n  const [isFocused, setFocused] = useBoolean()\n  const [eventSource, setEventSource] = useState<EventSource>()\n\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n  const [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? getDefaultValue(min, max),\n    onChange,\n  })\n\n  /**\n   * Slider uses DOM APIs to add and remove event listeners.\n   * Noticed some issues with React's synthetic events.\n   *\n   * We use `ref` to save the functions used to remove\n   * the event listeners.\n   *\n   * Ideally, we'll love to use pointer-events API but it is\n   * not fully supported in all browsers.\n   */\n  const cleanUpRef = useRef<Dict<Function>>({})\n\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n  const value = clampValue(computedValue, min, max)\n  const prev = useRef<number>()\n\n  const reversedValue = max - value + min\n  const trackValue = isReversed ? reversedValue : value\n  const trackPercent = valueToPercent(trackValue, min, max)\n\n  const isVertical = orientation === \"vertical\"\n\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n  const trackRef = useRef<any>(null)\n  const thumbRef = useRef<any>(null)\n  const rootRef = useRef<any>(null)\n\n  /**\n   * Generate unique ids for component parts\n   */\n  const [thumbId, trackId] = useIds(idProp, `slider-thumb`, `slider-track`)\n\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   */\n  const getValueFromPointer = useCallback(\n    (event) => {\n      if (!trackRef.current) return undefined\n\n      const trackRect = getBox(trackRef.current).borderBox\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical\n        ? trackRect.bottom - clientY\n        : clientX - trackRect.left\n\n      const length = isVertical ? trackRect.height : trackRect.width\n      let percent = diff / length\n\n      if (isReversed) {\n        percent = 1 - percent\n      }\n\n      let nextValue = percentToValue(percent, min, max)\n\n      if (step) {\n        nextValue = parseFloat(roundValueToStep(nextValue, min, step))\n      }\n\n      nextValue = clampValue(nextValue, min, max)\n\n      return nextValue\n    },\n    [isVertical, isReversed, max, min, step],\n  )\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  const constrain = useCallback(\n    (value: number) => {\n      // bail out if slider isn't interactive\n      if (!isInteractive) return\n      prev.current = value\n      value = parseFloat(roundValueToStep(value, min, oneStep))\n      value = clampValue(value, min, max)\n      setValue(value)\n    },\n    [oneStep, max, min, setValue, isInteractive],\n  )\n\n  const actions = useMemo(\n    () => ({\n      stepUp: (step = oneStep) => {\n        const next = isReversed ? value - step : value + step\n        constrain(next)\n      },\n      stepDown: (step = oneStep) => {\n        const next = isReversed ? value + step : value - step\n        constrain(next)\n      },\n      reset: () => constrain(defaultValue || 0),\n      stepTo: (value: number) => constrain(value),\n    }),\n    [constrain, isReversed, value, oneStep, defaultValue],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => actions.stepUp(),\n        ArrowUp: () => actions.stepUp(),\n        ArrowLeft: () => actions.stepDown(),\n        ArrowDown: () => actions.stepDown(),\n        PageUp: () => actions.stepUp(tenSteps),\n        PageDown: () => actions.stepDown(tenSteps),\n        Home: () => constrain(min),\n        End: () => constrain(max),\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        setEventSource(\"keyboard\")\n        action(event)\n      }\n    },\n    [actions, constrain, max, min, tenSteps],\n  )\n\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n  const valueText = getAriaValueText?.(value) ?? ariaValueText\n\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n  const thumbBoxModel = useDimensions(thumbRef)\n  const thumbRect = thumbBoxModel?.borderBox ?? {\n    width: 0,\n    height: 0,\n  }\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const thumbStyle: React.CSSProperties = {\n    position: \"absolute\",\n    userSelect: \"none\",\n    touchAction: \"none\",\n    ...orient({\n      orientation,\n      vertical: {\n        bottom: `calc(${trackPercent}% - ${thumbRect.height / 2}px)`,\n      },\n      horizontal: {\n        left: `calc(${trackPercent}% - ${thumbRect.width / 2}px)`,\n      },\n    }),\n  }\n\n  const rootStyle: React.CSSProperties = {\n    position: \"relative\",\n    touchAction: \"none\",\n    WebkitTapHighlightColor: \"rgba(0,0,0,0)\",\n    userSelect: \"none\",\n    outline: 0,\n    ...orient({\n      orientation,\n      vertical: {\n        paddingLeft: thumbRect.width / 2,\n        paddingRight: thumbRect.width / 2,\n      },\n      horizontal: {\n        paddingTop: thumbRect.height / 2,\n        paddingBottom: thumbRect.height / 2,\n      },\n    }),\n  }\n\n  const trackStyle: React.CSSProperties = {\n    position: \"absolute\",\n    ...orient({\n      orientation,\n      vertical: {\n        left: \"50%\",\n        transform: \"translateX(-50%)\",\n        height: \"100%\",\n      },\n      horizontal: {\n        top: \"50%\",\n        transform: \"translateY(-50%)\",\n        width: \"100%\",\n      },\n    }),\n  }\n\n  const innerTrackStyle: React.CSSProperties = {\n    ...trackStyle,\n    ...orient({\n      orientation,\n      vertical: isReversed\n        ? { height: `${100 - trackPercent}%`, top: 0 }\n        : { height: `${trackPercent}%`, bottom: 0 },\n      horizontal: isReversed\n        ? { width: `${100 - trackPercent}%`, right: 0 }\n        : { width: `${trackPercent}%`, left: 0 },\n    }),\n  }\n\n  useUpdateEffect(() => {\n    if (thumbRef.current && focusThumbOnChange) {\n      focus(thumbRef.current)\n    }\n  }, [value])\n\n  useUpdateEffect(() => {\n    const shouldUpdate =\n      !isDragging && eventSource !== \"keyboard\" && prev.current !== value\n\n    if (shouldUpdate) {\n      onChangeEnd?.(value)\n    }\n\n    if (eventSource === \"keyboard\") {\n      onChangeEnd?.(value)\n    }\n  }, [isDragging, onChangeEnd, value, eventSource])\n\n  const onMouseDown = useCallbackRef((event: MouseEvent) => {\n    /**\n     * Prevent update if it is right-click\n     */\n    if (isRightClick(event)) return\n\n    if (!isInteractive || !rootRef.current) return\n\n    setDragging.on()\n    prev.current = value\n    onChangeStart?.(value)\n\n    const doc = getOwnerDocument(rootRef.current)\n\n    const run = (event: MouseEvent) => {\n      const nextValue = getValueFromPointer(event)\n\n      if (nextValue != null) {\n        setEventSource(\"mouse\")\n        setValue(nextValue)\n      }\n    }\n\n    run(event)\n\n    doc?.addEventListener(\"mousemove\", run)\n\n    const clean = () => {\n      doc?.removeEventListener(\"mousemove\", run)\n      setDragging.off()\n    }\n\n    doc?.addEventListener(\"mouseup\", clean)\n    cleanUpRef.current.mouseup = () => {\n      doc?.removeEventListener(\"mouseup\", clean)\n    }\n  })\n\n  const onTouchStart = useCallbackRef((event: TouchEvent) => {\n    if (!isInteractive || !rootRef.current) return\n\n    // Prevent scrolling for touch events\n    event.preventDefault()\n\n    setDragging.on()\n    prev.current = value\n    onChangeStart?.(value)\n\n    const doc = getOwnerDocument(rootRef.current)\n\n    const run = (event: TouchEvent) => {\n      const nextValue = getValueFromPointer(event)\n\n      if (nextValue != null) {\n        setEventSource(\"touch\")\n        setValue(nextValue)\n      }\n    }\n\n    run(event)\n\n    doc?.addEventListener(\"touchmove\", run)\n\n    const clean = () => {\n      doc?.removeEventListener(\"touchmove\", run)\n      setDragging.off()\n    }\n\n    doc?.addEventListener(\"touchend\", clean)\n    doc?.addEventListener(\"touchcancel\", clean)\n\n    cleanUpRef.current.touchend = () => {\n      doc?.removeEventListener(\"touchend\", clean)\n    }\n\n    cleanUpRef.current.touchcancel = () => {\n      doc?.removeEventListener(\"touchcancel\", clean)\n    }\n  })\n\n  /**\n   * Remove all event handlers\n   */\n  const detach = () => {\n    Object.values(cleanUpRef.current).forEach((cleanup) => {\n      cleanup?.()\n    })\n    cleanUpRef.current = {}\n  }\n\n  /**\n   * Ensure we clean up listeners when slider unmounts\n   */\n  useUnmountEffect(detach)\n\n  useUpdateEffect(() => {\n    if (!isDragging) detach()\n  }, [isDragging])\n\n  cleanUpRef.current.mousedown = useEventListener(\n    \"mousedown\",\n    onMouseDown,\n    rootRef.current,\n  )\n\n  cleanUpRef.current.touchstart = useEventListener(\n    \"touchstart\",\n    onTouchStart,\n    rootRef.current,\n  )\n\n  const getRootProps: PropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ...htmlProps,\n    ref: mergeRefs(ref, rootRef),\n    tabIndex: -1,\n    \"aria-disabled\": ariaAttr(isDisabled),\n    \"data-focused\": dataAttr(isFocused),\n    style: {\n      ...props.style,\n      ...rootStyle,\n    },\n  })\n\n  const getTrackProps: PropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref: mergeRefs(ref, trackRef),\n    id: trackId,\n    \"data-disabled\": dataAttr(isDisabled),\n    style: {\n      ...props.style,\n      ...trackStyle,\n    },\n  })\n\n  const getInnerTrackProps: PropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref,\n    style: {\n      ...props.style,\n      ...innerTrackStyle,\n    },\n  })\n\n  const getThumbProps: PropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref: mergeRefs(ref, thumbRef),\n    role: \"slider\",\n    tabIndex: 0,\n    id: thumbId,\n    \"data-active\": dataAttr(isDragging),\n    \"aria-valuetext\": valueText,\n    \"aria-valuemin\": min,\n    \"aria-valuemax\": max,\n    \"aria-valuenow\": value,\n    \"aria-orientation\": orientation,\n    \"aria-disabled\": ariaAttr(isDisabled),\n    \"aria-readonly\": ariaAttr(isReadOnly),\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n    style: {\n      ...props.style,\n      ...thumbStyle,\n    },\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n    onFocus: callAllHandlers(props.onFocus, setFocused.on),\n    onBlur: callAllHandlers(props.onBlur, setFocused.off),\n  })\n\n  const getMarkerProps: PropGetter<any, { value?: any }> = (\n    props = {},\n    ref = null,\n  ) => {\n    const isInRange = !(props.value < min || props.value > max)\n    const isHighlighted = value >= props.value\n    const markerPercent = valueToPercent(props.value, min, max)\n\n    const markerStyle: React.CSSProperties = {\n      position: \"absolute\",\n      pointerEvents: \"none\",\n      ...orient({\n        orientation,\n        vertical: {\n          bottom: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`,\n        },\n        horizontal: {\n          left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`,\n        },\n      }),\n    }\n\n    return {\n      ...props,\n      ref,\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: {\n        ...props.style,\n        ...markerStyle,\n      },\n    }\n  }\n\n  const getInputProps: PropGetter<HTMLInputElement> = (\n    props = {},\n    ref = null,\n  ) => ({\n    ...props,\n    ref,\n    type: \"hidden\",\n    value,\n    name,\n  })\n\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging,\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n  }\n}\n\nexport type UseSliderReturn = ReturnType<typeof useSlider>\n\nfunction orient(options: {\n  orientation: UseSliderProps[\"orientation\"]\n  vertical: CSSProperties\n  horizontal: CSSProperties\n}) {\n  const { orientation, vertical, horizontal } = options\n  return orientation === \"vertical\" ? vertical : horizontal\n}\n\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\nfunction getDefaultValue(min: number, max: number) {\n  return max < min ? min : min + (max - min) / 2\n}\n"]},"metadata":{},"sourceType":"module"}