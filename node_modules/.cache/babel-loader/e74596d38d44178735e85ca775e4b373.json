{"ast":null,"code":"import * as React from \"react\";\nimport { isFunction } from \"./assertion\";\n/**\n * Creates a named context, provider, and hook.\n *\n * @param options create context options\n */\n\nexport function createContext(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$strict = _options.strict,\n      strict = _options$strict === void 0 ? true : _options$strict,\n      _options$errorMessage = _options.errorMessage,\n      errorMessage = _options$errorMessage === void 0 ? \"useContext: `context` is undefined. Seems you forgot to wrap component within the Provider\" : _options$errorMessage,\n      name = _options.name;\n  var Context = /*#__PURE__*/React.createContext(undefined);\n  Context.displayName = name;\n\n  function useContext() {\n    var context = React.useContext(Context);\n\n    if (!context && strict) {\n      throw new Error(errorMessage);\n    }\n\n    return context;\n  }\n\n  return [Context.Provider, useContext, Context];\n}\n/**\n * Gets only the valid children of a component,\n * and ignores any nullish or falsy child.\n *\n * @param children the children\n */\n\nexport function getValidChildren(children) {\n  return React.Children.toArray(children).filter(function (child) {\n    return /*#__PURE__*/React.isValidElement(child);\n  });\n}\n/**\n * Assigns a value to a ref function or object\n *\n * @param ref the ref to assign to\n * @param value the value\n */\n\nexport function assignRef(ref, value) {\n  if (ref == null) return;\n\n  if (isFunction(ref)) {\n    ref(value);\n    return;\n  }\n\n  try {\n    // @ts-ignore\n    ref.current = value;\n  } catch (error) {\n    throw new Error(\"Cannot assign value '\" + value + \"' to ref '\" + ref + \"'\");\n  }\n}\n/**\n * Combine multiple React refs into a single ref function.\n * This is used mostly when you need to allow consumers forward refs to\n * internal components\n *\n * @param refs refs to assign to value to\n */\n\nexport function mergeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return function (value) {\n    refs.forEach(function (ref) {\n      return assignRef(ref, value);\n    });\n  };\n}","map":{"version":3,"sources":["../../src/react-helpers.ts"],"names":["options","strict","errorMessage","name","Context","React","context","child","ref","isFunction","refs","value","assignRef"],"mappings":"AAAA,OAAO,KAAP,KAAA,MAAA,OAAA;AACA,SAAA,UAAA,QAAA,aAAA;AAoBA;;;;;;AAKA,OAAO,SAAA,aAAA,CAAA,OAAA,EAAwE;AAAA,MAApCA,OAAoC,KAAA,KAAA,CAAA,EAAA;AAApCA,IAAAA,OAAoC,GAAJ,EAAhCA;AAAoC;;AAAA,iBAC7E,OAD6E;AAAA,iCAE3EC,MAF2E;AAAA,MAE3EA,MAF2E,gCACvE,IADuE;AAAA,uCAG3EC,YAH2E;AAAA,MAG3EA,YAH2E,sCACvE,4FADuE;AAAA,MAI3EC,IAJ2E,YAI3EA,IAJ2E;AAO7E,MAAMC,OAAO,GAAA,aAAGC,KAAK,CAALA,aAAAA,CAAhB,SAAgBA,CAAhB;AAEAD,EAAAA,OAAO,CAAPA,WAAAA,GAAAA,IAAAA;;AAEA,WAAA,UAAA,GAAsB;AACpB,QAAME,OAAO,GAAGD,KAAK,CAALA,UAAAA,CAAhB,OAAgBA,CAAhB;;AAEA,QAAI,CAAA,OAAA,IAAJ,MAAA,EAAwB;AACtB,YAAM,IAAA,KAAA,CAAN,YAAM,CAAN;AACD;;AAED,WAAA,OAAA;AACD;;AAED,SAAO,CACLD,OAAO,CADF,QAAA,EAAA,UAAA,EAAP,OAAO,CAAP;AAKD;AAED;;;;;;;AAMA,OAAO,SAAA,gBAAA,CAAA,QAAA,EAAqD;AAC1D,SAAOC,KAAK,CAALA,QAAAA,CAAAA,OAAAA,CAAAA,QAAAA,EAAAA,MAAAA,CAAyCE,UAAAA,KAAD;AAAA,WAAA,aAC7CF,KAAK,CAALA,cAAAA,CADF,KACEA,CAD6C;AAAA,GAAxCA,CAAP;AAGD;AAID;;;;;;;AAMA,OAAO,SAAA,SAAA,CAAA,GAAA,EAAA,KAAA,EAAoE;AACzE,MAAIG,GAAG,IAAP,IAAA,EAAiB;;AAEjB,MAAIC,UAAU,CAAd,GAAc,CAAd,EAAqB;AACnBD,IAAAA,GAAG,CAAHA,KAAG,CAAHA;AACA;AACD;;AAED,MAAI;AACF;AACAA,IAAAA,GAAG,CAAHA,OAAAA,GAAAA,KAAAA;AAFF,GAAA,CAGE,OAAA,KAAA,EAAc;AACd,UAAM,IAAA,KAAA,CAAA,0BAAA,KAAA,GAAA,YAAA,GAAA,GAAA,GAAN,GAAM,CAAN;AACD;AACF;AAED;;;;;;;;AAOA,OAAO,SAAA,SAAA,GAA4D;AAAA,OAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAAnCE,IAAmC,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAAnCA,IAAAA,IAAmC,CAAA,IAAA,CAAnCA,GAAmC,SAAA,CAAA,IAAA,CAAnCA;AAAmC;;AACjE,SAAQC,UAAAA,KAAD,EAAc;AACnBD,IAAAA,IAAI,CAAJA,OAAAA,CAAcF,UAAAA,GAAD;AAAA,aAASI,SAAS,CAAA,GAAA,EAA/BF,KAA+B,CAAlB;AAAA,KAAbA;AADF,GAAA;AAGD","sourcesContent":["import * as React from \"react\"\nimport { isFunction } from \"./assertion\"\n\nexport interface CreateContextOptions {\n  /**\n   * If `true`, React will throw if context is `null` or `undefined`\n   * In some cases, you might want to support nested context, so you can set it to `false`\n   */\n  strict?: boolean\n  /**\n   * Error message to throw if the context is `undefined`\n   */\n  errorMessage?: string\n  /**\n   * The display name of the context\n   */\n  name?: string\n}\n\ntype CreateContextReturn<T> = [React.Provider<T>, () => T, React.Context<T>]\n\n/**\n * Creates a named context, provider, and hook.\n *\n * @param options create context options\n */\nexport function createContext<ContextType>(options: CreateContextOptions = {}) {\n  const {\n    strict = true,\n    errorMessage = \"useContext: `context` is undefined. Seems you forgot to wrap component within the Provider\",\n    name,\n  } = options\n\n  const Context = React.createContext<ContextType | undefined>(undefined)\n\n  Context.displayName = name\n\n  function useContext() {\n    const context = React.useContext(Context)\n\n    if (!context && strict) {\n      throw new Error(errorMessage)\n    }\n\n    return context\n  }\n\n  return [\n    Context.Provider,\n    useContext,\n    Context,\n  ] as CreateContextReturn<ContextType>\n}\n\n/**\n * Gets only the valid children of a component,\n * and ignores any nullish or falsy child.\n *\n * @param children the children\n */\nexport function getValidChildren(children: React.ReactNode) {\n  return React.Children.toArray(children).filter((child) =>\n    React.isValidElement(child),\n  ) as React.ReactElement[]\n}\n\ntype ReactRef<T> = React.Ref<T> | React.RefObject<T> | React.MutableRefObject<T>\n\n/**\n * Assigns a value to a ref function or object\n *\n * @param ref the ref to assign to\n * @param value the value\n */\nexport function assignRef<T = any>(ref: ReactRef<T> | undefined, value: T) {\n  if (ref == null) return\n\n  if (isFunction(ref)) {\n    ref(value)\n    return\n  }\n\n  try {\n    // @ts-ignore\n    ref.current = value\n  } catch (error) {\n    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`)\n  }\n}\n\n/**\n * Combine multiple React refs into a single ref function.\n * This is used mostly when you need to allow consumers forward refs to\n * internal components\n *\n * @param refs refs to assign to value to\n */\nexport function mergeRefs<T>(...refs: (ReactRef<T> | undefined)[]) {\n  return (value: T) => {\n    refs.forEach((ref) => assignRef(ref, value))\n  }\n}\n"]},"metadata":{},"sourceType":"module"}