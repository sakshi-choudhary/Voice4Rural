import { useSafeLayoutEffect } from "@chakra-ui/hooks";
import { fromEntries } from "@chakra-ui/utils";
import { createPopper as defaultCreatePopper } from "@popperjs/core";
import { dequal } from "dequal";
import * as React from "react";

function resolve(obj, elements) {
  return prev => {
    var next = fromEntries(elements.map(element => [element, obj[element]]));
    var isPopperEqual = dequal(prev.popper, next.popper);
    var isArrowEqual = dequal(prev.arrow, next.arrow);
    if (isArrowEqual && isPopperEqual) return prev;
    return next;
  };
}

var EMPTY_MODIFIERS = [];
export function usePopper(referenceElement, popperElement, options) {
  if (options === void 0) {
    options = {};
  }

  var {
    enabled = true
  } = options;
  var prevOptions = React.useRef(null);
  var optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS
  };
  var [styles, setStyles] = React.useState({
    popper: {
      position: optionsWithDefaults.strategy,
      left: "0",
      top: "0"
    }
  });
  var [attrs, setAttrs] = React.useState({});
  var updateStateModifier = React.useMemo(() => ({
    name: "updateState",
    enabled,
    phase: "write",
    fn: (_ref) => {
      var {
        state
      } = _ref;
      var elements = Object.keys(state.elements);
      setStyles(resolve(state.styles, elements));
      setAttrs(resolve(state.attributes, elements));
    },
    requires: ["computeStyles"]
  }), [enabled]);
  var popperOptions = React.useMemo(() => {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [...optionsWithDefaults.modifiers, updateStateModifier, {
        name: "applyStyles",
        enabled: false
      }]
    };

    if (dequal(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    }

    prevOptions.current = newOptions;
    return newOptions;
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = React.useRef();
  useSafeLayoutEffect(() => {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useSafeLayoutEffect(() => {
    if (referenceElement == null || popperElement == null) {
      return;
    }

    var createPopper = options.createPopper || defaultCreatePopper;
    var popperInstance = createPopper(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return () => {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  React.useEffect(() => {
    var id = requestAnimationFrame(() => {
      var _popperInstanceRef$cu;

      (_popperInstanceRef$cu = popperInstanceRef.current) == null ? void 0 : _popperInstanceRef$cu.forceUpdate();
    });
    return () => {
      cancelAnimationFrame(id);
    };
  }, []);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles,
    attributes: attrs,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
}
//# sourceMappingURL=react-popper.js.map